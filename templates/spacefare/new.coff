
height=800
T=require "halvalla"
B=require "backbone"
_= require "underscore"

rho = 50
powers = for i in [0..100]
  rho = rho * 1.61803398
dumpText= (text)->
  $("#reference").append T.render T.p text
rhoShow = T.render T.div =>
  for i in [0..10]
    T.p "rho^#{i}=#{powers[i]}. "
  return null
#$("#reference").append rhoShow

Ratios = [2,1,0,-1]
colorScheme = [
  '#e6194B', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#42d4f4', '#f032e6', '#bfef45', '#fabed4', '#469990', '#dcbeff', '#9A6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075', '#a9a9a9', '#ffffff', '#000000' ]


blades={}
for basis,i in [ "groucho","harpo","chico","stan","babe"]
   color =  seen.Colors.hex colorScheme[i]
   color.a = 140
   blades[basis] =
     angle: i*72
     slope: i * 2 * Math.PI/5
     points: []
     color: color

fillColor = seen.Colors.rgb 255,5,5
newDot =(theColor = fillColor, text="origin")->
  #shape = seen.Shapes.text(text, {font: '10px Roboto', cullBackfaces: false, anchor: 'left'}).fill('#000000')
  shape = new seen.Shape('tri', [new seen.Surface([seen.P(-1, -1, 0), seen.P(1, -1, 0), seen.P(0, 4, 0)])])
  shape.fill(new seen.Material(theColor)).scale 5

latticePoint = B.Model.extend()
latticePointCollection =B.Collection.extend
  model:latticePoint
latticePoints = new latticePointCollection()
addToLattice = (who,where,what,parent)->
  pointFinal = seen.P(0,0,0).transform(what.m).round()
  return null unless 1000 > pointFinal.magnitude()
  latticePoints.add
    id:what.surfaces[0].id
    blade: who
    offset: where
    pointFinal: pointFinal
    signature: siggy parent, who, where

latticeOrigin =new latticePoint
  id:"o0"
  blade:"origin"
  offset: 0
  pointFinal: seen.P 0,0,0
  signature: "_"
#latticePoints.add latticeOrigin
dot=null

seenModels = new seen.Models.default()
bladeScheme=  [ "groucho","harpo","chico","stan","babe","groucho","chico","babe","harpo","stan","groucho"]

class Paths
  # local p accumulates all Paths to a specific vertex from the origin
  constructor: ->
    @p = {}

  addPath: (v, data) ->
    bladesInPath =t = data.split '/'
    path= _.sortBy(t,(d)-> d)
    data= path.join '/'
    @p[v.x] ={} unless @p[v.x]
    data = validatePath data
    unless t= @p[v.x][v.y]
      @p[v.x][v.y] = [data]
      return true
    return false unless -1 == _.indexOf t, data
    t.unshift data
    return true
    
  validatePath= (data)->
    t= data.split '/'
    p=new seen.Matrix()
    for bl in t
      continue if bl == '_'
      m= bl.match /^(\w+)-(\d+)\.(\d)+$/
      alert bl unless m
      bl = blades[bl]
      p.translate(rho[m[3]],0,0).rotz(slope)
    o = new seen.P()
    o.multiply(p).round()
    str = "_#{o.x}|#{o.y}"+data
    return str

  mostPaths: ()->
    max = []
    for x,byY of @p
      for y,byXY of byY
        max = byXY if byXY.length >max.length
    return {x:x, y:y, max: max}
allPaths = new Paths()

siggy = (p,blade,exp)->
  "#{p.get "signature"}/#{blade}-#{blades[blade].angle}.#{exp}"

buildPoint = (i,parent)->
    return unless parent
    [blade1,blade2] = bladeScheme[i..i+1]
    {x,y,z} = parent.get "pointFinal"
    signature= "#{parent.get "signature"}/#{0}.#{blade1}"
    dot = newDot(blades[blade1].color,signature).translate(powers[0],0,0).rotz(blades[blade1].slope).translate x, y, z
    dot.bake().reset()
    allPaths.addPath seen.P(0,0,0).transform(dot.m).round(),signature
    bladeModel.add dot
    return parent2 = addToLattice blade1,i,dot,parent

Origin = new seen.Shape('tri', [new seen.Surface([seen.P(-1, -1, 0), seen.P(1, -1, 0), seen.P(0, 4, 0)])])
Origin.fill(new seen.Material('#880000')).scale 5
seenModels.add Origin

createEmplace2 = (parent = latticeOrigin)->
  bladeModel = seenModels.append()
  for i in [0..4]
    [blade1,blade2] = bladeScheme[i..i+1]
    {x,y,z} = parent.get "pointFinal"
    signature= siggy parent, blade1, 0
    #"#{parent.get "signature"}/#{0}.#{blade1}"
    dot = newDot(blades[blade1].color,signature).translate(powers[0],0,0).rotz(blades[blade1].slope).translate x, y, z
    dot.bake().reset()
    allPaths.addPath seen.P(0,0,0).transform(dot.m).round(),signature
    bladeModel.add dot
    parent2 = addToLattice blade1,1,dot,parent
    continue unless parent2
    ln1 = seen.Shapes.pipe  (parent.get "pointFinal"), parent2.get "pointFinal"
    ln1.fill "#123456"
    bladeModel.add ln1
    {x,y,z} = parent2.get "pointFinal"
    signature= siggy parent2, blade2, 0
    dot = newDot(blades[blade2].color,signature).translate(powers[0],0,0).rotz(blades[blade2].slope).translate x, y, z
    dot.bake().reset()
    allPaths.addPath seen.P(0,0,0).transform(dot.m).round(),signature
    bladeModel.add dot
    destination = addToLattice blade2,1,dot,parent2
    continue unless destination
    ln1 = seen.Shapes.pipe  (parent2.get "pointFinal"), destination.get "pointFinal"
    ln1.fill "#654321"
    bladeModel.add ln1

  for i in [5..9]
    [blade1,blade2] = bladeScheme[i..i+1]
    {x,y,z} = parent.get "pointFinal"
    signature= siggy parent, blade1, 1
    dot = newDot(blades[blade1].color,signature).translate(powers[1],0,0).rotz(blades[blade1].slope).translate x, y, z
    dot.bake().reset()
    allPaths.addPath seen.P(0,0,0).transform(dot.m).round(),signature
    bladeModel.add dot
    parent2 = addToLattice blade1,2,dot,parent
    continue unless parent2
    {x,y,z} = parent2.get "pointFinal"
    signature= siggy parent2, blade2, 1
    dot = newDot(blades[blade2].color,signature).translate(powers[1],0,0).rotz(blades[blade2].slope).translate x, y, z
    dot.bake().reset()
    allPaths.addPath seen.P(0,0,0).transform(dot.m).round(),signature
    bladeModel.add dot
    addToLattice blade2,2,dot,parent2

createEmplace2()
primaryLatticePoints = latticePoints
latticePoints = new latticePointCollection()
primaryLatticePoints.forEach (l)-> createEmplace2 l
secondaryLatticePoints = latticePoints
latticePoints = new latticePointCollection()
secondaryLatticePoints.forEach (l)-> createEmplace2 l

dumpText "JAH here"
dumpText latticePoints.length
g= allPaths.mostPaths()
dumpText JSON.stringify {x:g.x, y:g.y}
for t in _.sortBy g.max,(x)->x
  dumpText t

#latticePoints.forEach (l)->dumpText JSON.stringify l.toJSON()
#fillColor = seen.Colors.rgb 25,99,188,40
dumpText "JAH where"
dumpText latticePoints.length

dumpText "JAH nowhere"

#
# Create scene and add shape to model
scene = new seen.Scene
  model    : bigM = seenModels
  viewport : seen.Viewports.center(height, height)
  camera   : new seen.Camera
          projection : seen.Projections.perspective()

# Create render context from canvas
context = seen.Context 'seen-canvas', scene
context.render()

#dragger = new seen.Drag('seen-canvas', {inertia : true})
#dragger.on 'drag.rotate', (e) ->
#  bigM.transform seen.Quaternion.xyToTransform(e.offsetRelative...)
#  context.render()

