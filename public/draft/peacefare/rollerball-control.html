<!DOCTYPE html><html><head><base href="/" /><meta name="author" content="James A. Hinds: The Celarien's best friend.  I'm not him, I wear glasses" /><meta http-equiv="Content-Type" content="text/html" charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>A Fountainhead of Strategies, techniques and other stuff</title><meta name="description" content="Brainstorms, ideas and such" /><meta name="keywords" content="brain candy, ideas, strategies, techniques" /><script>document.styling = {"palx":"#03c","black":"#000","white":"#fff"}</script><link rel="apple-touch-icon" sizes="57x57" href="/assets/icons/apple-icon-57x57.png" /><link rel="apple-touch-icon" sizes="60x60" href="/assets/icons/apple-icon-60x60.png" /><link rel="apple-touch-icon" sizes="72x72" href="/assets/icons/apple-icon-72x72.png" /><link rel="apple-touch-icon" sizes="76x76" href="/assets/icons/apple-icon-76x76.png" /><link rel="apple-touch-icon" sizes="114x114" href="/assets/icons/apple-icon-114x114.png" /><link rel="apple-touch-icon" sizes="120x120" href="/assets/icons/apple-icon-120x120.png" /><link rel="apple-touch-icon" sizes="144x144" href="/assets/icons/apple-icon-144x144.png" /><link rel="apple-touch-icon" sizes="152x152" href="/assets/icons/apple-icon-152x152.png" /><link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-icon-180x180.png" /><link rel="icon" type="image/png" sizes="192x192" href="/assets/icons/android-icon-192x192.png" /><link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png" /><link rel="icon" type="image/png" sizes="96x96" href="/assets/icons/favicon-96x96.png" /><link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png" /><link rel="manifest" href="/assets/manifest.json" /><meta name="msapplication-TileColor" content="#ffffff" /><meta name="msapplication-TileImage" content="/assets/icons/ms-icon-144x144.png" /><meta name="theme-color" content="#ffffff" /><link rel="stylesheet" href="assets/css/vendor.css" -content--encoding="gzip" /><link rel="stylesheet" href="assets/css/app.css" -content--encoding="gzip" /><link rel="shortcut icon" href="assets/icons/favicon.ico" type="image/x-icon" /><link rel="icon" href="assets/icons/favicon.ico" type="image/x-icon" /><script src="allstories.json"></script><script src="mystories.json"></script><script src="assets/js/vendor.js" -content--type="text/javascript" -content--encoding="gzip"></script><script src="assets/js/app.js" -content--type="text/javascript" -content--encoding="gzip"></script><script>siteHandle = '411-source'; topDomain = '411-source.com'; require('initialize');</script><style>#cover {
top: 0;
left: 0;
position: fixed;
background-repeat: no-repeat;
background-size: cover;
z-index: -1;
height:100%;
width:100%;
}</style><script src="assets/seen.min.js"></script><script src="draft/peacefare/rollerball/cannon.js"></script><script src="draft/peacefare/rollerball/pid.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/coffee-script/1.7.1/coffee-script.min.js"></script><script type="text/coffeescript"></script><style type="text/css">.console {
 background: #fff;
 color: #000;
 padding: 0;
 position: relative;
}
.console * {
 border: 0;
 font: normal 14px/1.3 Consolas,'Andale Mono','Courier New',Courier,monospace;
 margin: 0;
 outline: 0;
 padding: 0;
}
.console textarea {
 background: transparent;
 color: #000;
 display: block;
 overflow: hidden;
 resize: none;
 vertical-align: middle;
 width: 100%;
 word-wrap: normal;
}
.console-container {
 max-height: 100%;
 overflow: auto;
}
.console-container span.string {
 color: #c00;
}
.console-container span.string::before,
.console-container span.string::after {
 color: #333;
 content: '"';
}
.console-container span.number {
 color: #00f;
}
.console-container span.null,
.console-container span.undefined {
 color: #999;
}
.console-container ol.array {
display: inline-block;
}
.console-container ol.array::before {
 color: #999;
 content: '[';
}
.console-container ol.array::after {
 color: #999;
 content: ']';
}
.console-container ol.array li {
 display: inline-block;
}
.console-container ol.array li::after {
 color: #999;
 content: ',';
}
.console-container ol.array li:last-child::after {
 content: none;
}
.console-container dl.object::before {
 color: #000;
 content: '{';
}
.console-container dl.object::after {
 color: #000;
 content: '}';
 margin-left: 0.5em;
}
.console-container dl {
 display: inline-block;
}
.console-container dl.object dt, .console-container dl.object dd {
 display: inline-block;
}
.console-container dl.object dt {
 color: #909;
 margin-left: 0.5em;
}
.console-container dl.object dt::after {
 color: #000;
 content: ':';
 margin-right: 0.25em;
}
.console-container dl.object dd::after {
 content: ',';
}
.console-container dl.object dd:last-child::after {
 content: none;
}
.console-container div.element div.open,
.console-container div.element div.close {
 color: #909;
 display: inline;
}
.console-container div.element div.open::before {
 content: '<';
}
.console-container div.element div.close::before {
 content: '</';
}
.console-container div.element div.open::after,
.console-container div.element div.close::after {
 content: '>';
}
.console-container div.element div.content {
 display: none;
}
.console-container div.element dl,
.console-container div.element dt,
.console-container div.element dd {
 display: inline;
}
.console-container div.element dt {
 color: #c00;
 margin-left: 0.5em;
}
.console-container div.element dt::after {
 content: '=';
}
.console-container div.element dd {
 color: #00f;
}
.console-container div.element dd::before,
.console-container div.element dd::after {
 color: #c00;
 content: '"';
}
.console-container p {
 padding-left: 15px;
 position: relative;
}
.console-container p::before {
 color: #ccc;
 content: '>';
 left: 0;
 position: absolute;
 text-align: center;
 top: 0;
 vertical-align: middle;
 width: 15px;
}
.console-container p.console-input::before {
 color: #39f;
}
.console-container p div.command {
 color: #39f;
 white-space: pre;
}
.console-container p.error div.result {
 color: #f00;
}</style></head><body onload="Pylon.trigger('loaded')"><div class="fixed" style="background: url(/assets/images/hooray-fade2.jpg) no-repeat center fixed; -moz-transform:scaleX(-1);-o-transform:scaleX(-1);-webkit-transform:scaleX(-1);transform:scaleX(-1);filter:FlipH;ms-filter:FlipH "></div><div id="411-source-body" class="container-fluid bg-transparent"><div class="row"></div><div class="row" style="min-height:100vh"><div class="row"><div id="storybar" class="col col-12 col-md-9"><div id="mainline" class="bg-silver u-shadow"><header class="c-card__header"><h2 class="c-heading c-heading--small">rollerball-control<div class="c-heading__sub">---</div></h2></header><div class="c-card__body"><div class="m1 bg-darken-1"><h3>The LowRoller version of the RollerBall</h3><div id="bloviation" class="contents"><p>Did you ever see a Samuri movie where the police take down a rampaging samuri?</p><p>They simply surrounded the samuri with wooden staffs to keep him farther than swords length, and poked him until he gave up.  we have nothing like that for a man with a gun.  Enter the LowRoller</p><p>The LowRoller rollerBall is about the size of a basketball or soccerball.  It is
covered with a hard shell with a surface like leather.  It's mass is a few kilograms.
It can alter it's center of gravity to roll around.  that's it.</p><p>Even with that limitation, it can gang up at the feet of a person causing a threat.
The random motions of the balls will make the attacker lose balance and be unable to continue.</p><p>Press the spacebar to start and stop the simulation.  The large ball is a meter in diameter.
press '.' to single step the simulation.</p><canvas id="seen-canvas" width="400" height="400"></canvas><p>Press hjkl to change where these rollerballs take down an attacker.</p><p>Rotate the view with click and drag.  Zoom with fingers or mouse wheel.</p></div></div></div><footer class="c-card__footer"><p class="c-text--quiet">that's all--</p></footer></div></div><div class="col col-12 col-md-3"><aside id="sidebarx" class="o-grid__cell o-grid__cell--width-20 p2 bg-darken-2" style="min-width:240"></aside></div><div id="sidecar" class="flex-auto order-last bg-darken-2" style="min-width:240"><div class="fb-login-button" width="200" data-width="200" data-max-rows="1" data-size="medium" data-button-type="login_with" data-show-faces="true" data-auto-logout-link="true" data-use-continue-as="true"></div><div id="fb-status"></div></div></div></div><div id="console0" data-limit="10"></div><script type="text/javascript">(function() {
  var slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
  (function () {
    var FLIPXZ, FLIPYZ, RollerBall, TetraForcer, allBall, avatar, balls, bind, context, dragger, dropTime, floor, groundBody, groundShape, height, j, leather, m, n, onceStop, scene, seenModel, simulateThem, startStop, timeStamp, width, world, x, xform, y, zoomer;
    T = Pylon.Halvalla;
    bind = function(func, inst) {
      var args;
      args = toArray(arguments).slice(2);
      return function() {
        func.apply(inst || this, args.concat(toArray(arguments)));
      };
    };
    (function() {
      var Console, History, addClass, consoles, create, extend, listen, output, text, toArray, typeOf;
      consoles = {};
      History = function() {
        var history, index;
        index = -1;
        history = [];
        return extend(this, {
          clear: function() {
            history = [];
          },
          reset: function() {
            index = history.length;
          },
          previous: function() {
            return history[index = Math.max(--index, 0)];
          },
          next: function() {
            return history[index = Math.min(++index, history.length)];
          },
          push: function(data) {
            if (history[history.length - 1] !== data) {
              history.push(data);
              this.reset();
            }
          }
        });
      };
      Console = function(el, scope) {
        var console, container, exec, history, input, inputContainer, jsonize, limbo, log, node, original;
        jsonize = function(msg) {
          var serializer, stringify;
          stringify = function(obj, replacer, spaces, cycleReplacer) {
            return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
          };
          serializer = function(replacer, cycleReplacer) {
            var keys, stack;
            stack = [];
            keys = [];
            if (cycleReplacer === null) {
              cycleReplacer = function(key, value) {
                if (stack[0] === value) {
                  return '[Circular ~]';
                }
                return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';
              };
            }
            return function(key, value) {
              var thisPos;
              if (stack.length > 0) {
                thisPos = stack.indexOf(this);
                if (~thisPos) {
                  stack.splice(thisPos + 1);
                } else {
                  stack.push(this);
                }
                if (~thisPos) {
                  keys.splice(thisPos, 2e308, key);
                } else {
                  keys.push(key);
                }
                if (~stack.indexOf(value)) {
                  value = cycleReplacer.call(this, key, value);
                }
              } else {
                stack.push(value);
              }
              if (replacer === null) {
                return value;
              } else {
                return replacer.call(this, key, value);
              }
            };
          };
        };
        log = function(level) {
          var children, elT, firstElement, max, msg, result;
          msg = arguments.length === 2 ? arguments[1] : toArray(arguments).slice(1);
          result = create('div', {
            'class': 'result'
          }, output(msg));
          elT = addClass(create('p', null, result), typeOf(msg), level);
          firstElement = container.firstChild;
          container.insertBefore(elT, container.firstChild);
          children = container.childNodes;
          max = container.parentNode.dataset.limit || 20;
          while (children.length > max) {
            container.removeChild(children[children.length - 2]);
          }
          return elT;
        };
        exec = function(command) {
          var cmd, elT, err, level, msg;
          if (!command) {
            return;
          }
          cmd = text(create('div', {
            'class': 'command'
          }), command);
          level = 'info';
          msg = void 0;
          try {
            msg = (function(scope) {
              return eval(command);
            }).call(scope);
          } catch (error) {
            err = error;
            msg = err;
            level = 'error';
          }
          elT = log(level, msg);
          elT.insertBefore(cmd, elT.childNodes[0]);
          elT.scrollTop = elT.scrollHeight;
          container.scrollTop = container.scrollHeight;
          history.push(command);
        };
        if (typeof el === 'string') {
          el = document.getElementById(el);
        }
        console = consoles[el];
        if (console) {
          console.cd(scope);
          return console;
        } else if (!(this instanceof Console)) {
          if (!console) {
            console = new Console(el, scope);
          }
          return console;
        }
        consoles[el] = this;
        scope || (scope = window);
        limbo = create('div');
        while (node = el.childNodes[0]) {
          limbo.appendChild(node);
        }
        container = create('div', {
          'class': 'console-container'
        });
        inputContainer = create('p', {
          'class': 'console-input'
        });
        input = create('textarea', {
          row: 1
        });
        original = {
          className: el.className,
          tabIndex: el.tabIndex
        };
        inputContainer.appendChild(input);
        container.appendChild(inputContainer);
        addClass(el, 'console').appendChild(container);
        if (el.tabIndex < 0) {
          el.tabIndex = 0;
        }
        listen(el, 'focus', function() {
          input.focus();
        });
        history = new History;
        listen(input, 'keydown', function(event) {
          var cmd;
          switch (event.keyCode) {
            case 13:
              event.preventDefault();
              exec(this.value);
              this.value = '';
              return false;
            case 38:
              if (cmd = history.previous()) {
                input.value = cmd;
              }
              event.preventDefault();
              return false;
            case 40:
              if (cmd = history.next()) {
                input.value = cmd;
              } else {
                input.value = '';
              }
              event.preventDefault();
              return false;
          }
        });
        listen(input, 'blur', function() {
          history.reset();
        });
        return extend(this, {
          cd: function(s) {
            scope = s;
          },
          setDepth: (function(_this) {
            return function(d) {
              return _this.depth = d;
            };
          })(this),
          log: function() {
            this.info.apply(this, arguments);
          },
          info: bind(log, this, 'info'),
          warn: bind(log, this, 'warn'),
          error: bind(log, this, 'error'),
          clear: function() {
            var el;
            var elT, prev;
            prev = inputContainer.previousSibling;
            while (prev) {
              elT = prev;
              prev = elT.previousSibling;
              elT.parentNode.removeChild(elT);
            }
          },
          destroy: function() {
            var k;
            for (k in original) {
              el[k] = original[k];
            }
            while (node = el.childNodes[0]) {
              el.removeChild(node);
            }
            while (node = limbo.childNodes[0]) {
              el.appendChild(node);
            }
          }
        });
      };
      create = function(tagName, attrs) {
        var el, i, k;
        el = document.createElement(tagName);
        if (attrs) {
          for (k in attrs) {
            el.setAttribute(k, attrs[k]);
          }
        }
        i = 2;
        while (i < arguments.length) {
          el.appendChild(arguments[i]);
          ++i;
        }
        return el;
      };
      text = function(el, text) {
        if (typeof el === 'string' || typeof el === 'number') {
          return document.createTextNode(el);
        }
        el.appendChild(document.createTextNode(text));
        return el;
      };
      addClass = function(el) {
        var i;
        var classes, i;
        classes = [];
        i = 1;
        while (i < arguments.length) {
          classes = classes.concat(arguments[i].split(/\s+/));
          ++i;
        }
        if (el.classList) {
          for (i in classes) {
            el.classList.add(classes[i]);
          }
        } else {
          classes = el.className.split(/\s+/).concat(classes);
          el.className = classes.join(' ');
        }
        return el;
      };
      listen = function(el, event, callback) {
        var onevent;
        onevent = 'on' + event;
        if (el.addEventListener) {
          return el.addEventListener(event, callback, false);
        } else if (el.attachEvent) {
          return el.attachEvent(onevent, callback);
        } else if (onevent in el) {
          return el[onevent] = callback;
        }
      };
      extend = function(src) {
        var i, k, obj;
        i = 1;
        while (i < arguments.length) {
          obj = arguments[i];
          for (k in obj) {
            src[k] = obj[k];
          }
          ++i;
        }
        return src;
      };
      toArray = function(arr) {
        return Array.prototype.slice.call(arr);
      };
      bind = function(func, inst) {
        var args;
        args = toArray(arguments).slice(2);
        return function() {
          func.apply(inst || this, args.concat(toArray(arguments)));
        };
      };
      typeOf = function(obj) {
        if (Object.prototype.toString.call(obj) === '[object Array]') {
          return 'array';
        } else if (Object.prototype.toString.call(obj) === '[object Error]') {
          return 'error';
        } else if (obj === null) {
          return 'null';
        } else if (obj && obj.nodeType === 1) {
          return 'element';
        } else {
          return typeof obj;
        }
      };
      output = function(result, deep) {
        var arr, attr, attrs, close, html, i, k, nodeName, obj, open, type, val;
        if (deep == null) {
          deep = this.depth;
        }
        var val;
        var i;
        type = typeOf(result);
        switch (type) {
          case 'null':
          case 'undefined':
            return create('span', {
              'class': type
            }, text(type));
          case 'array':
            arr = create('ol', {
              'class': type
            });
            for (i in result) {
              val = result[i];
              arr.appendChild(create('li', null, output(val, deep - 1)));
            }
            return arr;
          case 'object':
            obj = create('dl', {
              'class': type
            });
            for (k in result) {
              if (!(k in result.__proto__)) {
                val = deep === 0 ? text(k) : output(result[k], deep - 1);
                obj.appendChild(create('dt', null, text(k)));
                obj.appendChild(create('dd', null, val));
              }
            }
            return obj;
          case 'element':
            nodeName = result.nodeName.toLowerCase();
            attrs = create('dl');
            open = create('div', {
              'class': 'open'
            }, text(nodeName), attrs);
            close = create('div', {
              'class': 'close'
            }, text(nodeName));
            html = create('div', {
              'class': 'content'
            }, text(result.innerHTML));
            i = 0;
            while (i < result.attributes.length) {
              attr = result.attributes[i];
              attrs.appendChild(create('dt', null, text(attr.name)));
              attrs.appendChild(create('dd', null, text(attr.value)));
              ++i;
            }
            return create('div', {
              'class': type
            }, open, html, close);
          case 'number':
            return create('span', {
              'class': type
            }, text(result.toFixed(2)));
          default:
            return create('span', {
              'class': type
            }, text(result.toString()));
        }
      };
      Console.log = function() {};
      window.Console = Console;
    })();
    TetraForcer = (function() {
      var MINFORCE;

      MINFORCE = 25;

      function TetraForcer(body, e1) {
        this.e = e1;
        this.seek = bind1(this.seek, this);
        this.tetraPoint = this.e.cannonLocal;
        this.outerSphere = body.outerSphere;
        this.innerSphere = body.innerSphere;
        this.body = body;
        this.seekerPID = new PID(-100, 1, -0.1, 1 / 60.0);
        this.seekerPID.setTarget = 0;
        this.seek = bind(this.seek, this);
        this.jamming = false;
        this.jamForce;

        /*
        Pylon.on "slider-#{@e.index}:jam", (event)=>
          @jam event.value
        @shifter = 0    
        Pylon.on "slider-#{@e.index}:shift", (event)=>
          @shifter = event.value  
        return
            jam: (forceValue) => # the real world position
        @jamming = true
        @jamForce = forceValue
         */
        return;
      }

      TetraForcer.prototype.seek = function(pursuit) {
        var adjust, force, seekPosition, seekVector, tetraPosition, tetraVector;
        pursuit.z = this.body.radius * 2;
        seekVector = pursuit.vsub(this.outerSphere.position);
        seekPosition = this.outerSphere.position.vadd(seekVector.unit().scale(this.body.radius * .8));
        tetraPosition = this.outerSphere.pointToWorldFrame(this.tetraPoint);
        force = MINFORCE;
        this.tetraToPursuit = pursuit.distanceTo(tetraPosition);
        this.tetraToPursuit = seekPosition.distanceTo(tetraPosition);
        this.toInnie = this.innerSphere.position.distanceTo(seekPosition);
        this.innieToPursuit = pursuit.distanceTo(this.innerSphere.position);
        this.tetraToInnie = tetraPosition.distanceTo(this.innerSphere.position);
        if (this.tetraToPursuit < this.tetraToInnie) {
          adjust = this.toInnie;
        } else {
          adjust = 0;
        }
        adjust = this.seekerPID.update(adjust);
        if (this.jamming) {
          this.force = force + (this.jamForce - 128) / 255;
        } else {
          this.force = force + adjust;
        }
        tetraVector = (tetraPosition.vsub(this.innerSphere.position)).unit().scale(this.body.mass);
        this.innerSphere.applyForce(tetraVector.scale(this.force), this.innerSphere.position);
        this.outerSphere.applyForce(tetraVector.scale(this.force * -1), tetraPosition);
      };

      return TetraForcer;

    })();
    RollerBall = (function() {
      var C, TETRAHEDRON_COORDINATE_MAP, tetrahedralDescription, tetrahedralSphere, tetrahedronPoints, toPoint, toVec3;

      toVec3 = function(p) {
        return new CANNON.Vec3(p.x / 10, p.y / 10, p.z / 10);
      };

      toPoint = function(v) {
        return seen.P(v.x * 10, v.y * 10, v.z * 10);
      };

      C = function(x, y, z) {
        if (x == null) {
          x = 0;
        }
        if (y == null) {
          y = 0;
        }
        if (z == null) {
          z = 0;
        }
        return new CANNON.Vec3(x, y, z);
      };

      TETRAHEDRON_COORDINATE_MAP = [[0, 2, 1], [0, 1, 3], [3, 2, 0], [1, 2, 3]];

      tetrahedronPoints = [seen.P(1, 1, 1), seen.P(-1, -1, 1), seen.P(-1, 1, -1), seen.P(1, -1, -1)];

      tetrahedralDescription = [];

      (function() {
        var j, len, len1, n, r, y, z;
        r = [1, -1];
        for (j = 0, len = r.length; j < len; j++) {
          z = r[j];
          for (n = 0, len1 = r.length; n < len1; n++) {
            y = r[n];
            tetrahedralDescription.push({
              p: seen.P(z * y, y, z),
              raw: [z * y, y, z],
              cannonLocal: C(z * y, y, z),
              index: tetrahedralDescription.length,
              flip: 1
            });
          }
        }
      })();

      tetrahedralSphere = function(subdivisions) {
        var i, j, len, len1, n, o, p, ref, triangle, triangles;
        if (subdivisions == null) {
          subdivisions = 2;
        }
        triangles = TETRAHEDRON_COORDINATE_MAP.map(function(coords) {
          return coords.map(function(c) {
            return tetrahedronPoints[c];
          });
        });
        for (i = j = 0, ref = subdivisions; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          triangles = seen.Shapes._subdivideTriangles(triangles);
          for (n = 0, len = triangles.length; n < len; n++) {
            triangle = triangles[n];
            for (o = 0, len1 = triangle.length; o < len1; o++) {
              p = triangle[o];
              p.normalize();
            }
          }
        }
        return new seen.Shape('tetrahedralSphere', triangles.map(function(triangle) {
          return new seen.Surface(triangle.map(function(v) {
            return v.copy();
          }));
        }));
      };

      RollerBall.prototype.accessControlPoints = function(f) {
        var element, j, len, ref, results;
        ref = this.controlPoints;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          element = ref[j];
          results.push(f(element));
        }
        return results;
      };

      window.bind1 = bind;

      RollerBall.prototype.setPursuit = function(x, y) {
        var marker, p1, p2;
        this.pursuit = new CANNON.Vec3(x, y, -10);
        p1 = toPoint(this.pursuit);
        p1.z = 2;
        p2 = p1.copy().add(seen.P(0, 0, 5));
        marker = seen.Shapes.pipe(p1, p2, 0.3, 6);
        this.avatar.add(marker.fill(new seen.Material(seen.C(20, 20, 20))));
      };

      function RollerBall(name, world, mass, radius, options) {
        var colorHex, defaultOptions, hull, tetraNames, v;
        if (mass == null) {
          mass = 1;
        }
        if (radius == null) {
          radius = 0.2;
        }
        if (options == null) {
          options = {};
        }
        this.clear = bind1(this.clear, this);
        this.accessControlPoints = bind1(this.accessControlPoints, this);
        this.A = name;
        this.world = world;
        this.scene = world.scene;
        this.avatar = world.scene.model;
        this.mass = mass;
        this.radius = radius;
        this.setPursuit(0, 0);
        this.controlPoints = (function() {
          var j, len, results;
          results = [];
          for (j = 0, len = tetrahedralDescription.length; j < len; j++) {
            v = tetrahedralDescription[j];
            results.push(Object.assign({}, v));
          }
          return results;
        })();
        defaultOptions = {
          massRatio: 0.1,
          innerRatio: 0.1,
          position: seen.P()
        };
        this.config = Object.assign({}, defaultOptions, options);
        this.innerSphere = new CANNON.Body({
          mass: this.mass * (1 - this.config.massRatio),
          position: this.config.position,
          shape: new CANNON.Sphere(this.radius * this.config.innerRatio)
        });
        this.outerSphere = new CANNON.Body({
          mass: this.mass * this.config.massRatio,
          angularDamping: 0.1,
          position: this.config.position,
          shape: new CANNON.Sphere(this.radius)
        });
        this.innerSphere.aName = this.A + ".Innie";
        this.innerSphere.collisionFilterGroup = 1;
        this.innerSphere.collisionFilterMask = 1;
        this.outerSphere.aName = this.A + ".Outie";
        this.outerSphere.collisionFilterGroup = 2;
        this.outerSphere.collisionFilterMask = 2;
        this.world.addBody(this.innerSphere);
        this.world.addBody(this.outerSphere);
        this.accessControlPoints((function(_this) {
          return function(e) {
            return e.tetraForcer = new TetraForcer(_this, e);
          };
        })(this));
        world.addEventListener("preStep", (function(_this) {
          return function(event) {
            var who;
            who = _this.A;
            _this.accessControlPoints(function(e) {
              return e.tetraForcer.seek(_this.pursuit);
            });
          };
        })(this));
        world.addEventListener("postStep", (function(_this) {
          return function(event) {
            _this.innerSphere.velocity.scale(.97, _this.innerSphere.velocity);
            _this.outerSphere.velocity.scale(.98, _this.outerSphere.velocity);
          };
        })(this));
        this.avatar.add(this.innerHull = seen.Shapes.tetrahedron().scale(10 * this.radius * this.config.innerRatio).stroke(new seen.Material(seen.C(20, 200, 200, 200))));
        this.innerHull.fill(new seen.Material('hsla(0,0,0,1)'));
        this.innerHull.bake();
        this.outerHull = new seen.Model();
        this.outerHull.add(hull = tetrahedralSphere(4).scale(this.radius * 10).fill(new seen.Material(seen.C(200, 200, 20, 200))));
        this.outerHull.bake();
        tetraNames = ["orange", "blue", "green", "violet"];
        colorHex = ["#FDD459", "#46e1d4", "#24C52B", "#C31A96"];
        this.accessControlPoints(function(e) {
          return e.viewAttributes = {
            name: tetraNames[e.index],
            color: colorHex[e.index]
          };
        });
        this.accessControlPoints((function(_this) {
          return function(e) {
            var pInner, pOuter, rc, strut;
            pInner = e.p.copy().multiply(5 * _this.radius * _this.config.innerRatio);
            pOuter = e.p.copy().multiply(5 * _this.radius);
            strut = seen.Shapes.pipe(pOuter, pInner, 0.1, 3);
            strut.name = e.viewAttributes.name;
            e.strut = strut;
            rc = seen.Colors.parse(e.viewAttributes.color);
            _this.avatar.add(strut.fill(new seen.Material(rc)));
            rc = seen.Colors.parse(e.viewAttributes.color);
            return rc.a = 128;

            /*
            el = document.getElementById('sliders')
            #debugger
            what = document.createElement("div")
            what.innerHTML= T.render ()->
              ident = "slider-#{e.index}"
              T.input "##{ident}",type:"range", min:0,max:255,oninput: "Pylon.trigger('#{ident}:jam',this);"
              T.label for: ident,e.viewAttributes.name
              T.input "##{ident}-watch.right",type:"range", min:0,max:255
              T.input "##{ident}-shift.right",type:"range", min:0,max:255, oninput: "Pylon.trigger('#{ident}:shift',this);"
            el.appendChild what
            Pylon.on "slider-#{e.index}:watch",(f)=>
              el=document.getElementById "slider-#{e.index}-watch"
              el.value = f*7-128
              return
             */
          };
        })(this));
        this.avatar.add(this.outerHull);
        return;
      }

      RollerBall.prototype.update = function() {
        var pi, po, pr, rotation, who;
        who = this.A;
        po = toPoint(this.outerSphere.position);
        pr = this.outerSphere.quaternion;
        rotation = new seen.Quaternion(pr.x, pr.y, pr.z, pr.w);
        pi = toPoint(this.innerSphere.position);
        this.innerHull.reset().transform(rotation.toMatrix());
        this.innerHull.translate(pi.x, pi.y, pi.z);
        this.outerHull.reset().transform(rotation.toMatrix());
        this.outerHull.translate(po.x, po.y, po.z);
        this.accessControlPoints((function(_this) {
          return function(e) {
            var angle, bottom, ls, obtuse, perp, r, size, top, vio, viol, vis, visl, vos, vosl, wi, wo, ws;
            vio = (wo = _this.innerSphere.position).vsub((wi = _this.outerSphere.position));
            ls = e.cannonLocal.unit().scale(_this.radius);
            ws = _this.outerSphere.pointToWorldFrame(ls);
            vos = wo.vsub(ws);
            vis = wi.clone().vsub(ws);
            perp = vis.cross(vos);
            perp.normalize();
            visl = vis.length();
            vosl = vos.length();
            viol = vio.length();
            top = visl * visl + vosl * vosl - viol * viol;
            bottom = 2 * visl * vosl;
            angle = Math.acos(top / bottom);
            obtuse = viol > vosl + visl;
            if (obtuse) {
              if (angle < Math.PI) {
                angle = Math.PI * 2 - angle;
              }
            } else {
              if (angle > Math.PI) {
                angle = Math.PI * 2 - angle;
              }
            }
            if (e.tetraForcer.shifter) {
              angle = 2 * Math.PI * e.tetraForcer.shifter / 255;
            }
            r = seen.Quaternion.axisAngle(perp.x, perp.y, perp.z, angle);
            size = _this.radius * 5 * (1 - _this.config.innerRatio);
            e.strut.reset();
            r = r.multiply(rotation).toMatrix();
            e.strut.transform(r);
            e.strut.translate(wo.x * 10, wo.y * 10, wo.z * 10);
          };
        })(this));
      };

      RollerBall.prototype.clear = function() {
        return this.accessControlPoints(function(e) {
          e.tetraForcer.shifter = 0;
          e.tetraForcer.jamming = false;
        });
      };

      return RollerBall;

    })();
    world = new CANNON.World;
    world.gravity.set(0, 0, -9.82);
    leather = new CANNON.Material({
      friction: .3,
      restitution: 0.3
    });
    world.defaultMaterial.friction = 0.3;
    world.defaultMaterial.restitution = 0.3;
    groundBody = new CANNON.Body({
      mass: 0
    });
    groundShape = new CANNON.Plane;
    groundBody.addShape(groundShape);
    groundBody.aName = "floorie";
    groundBody.collisionFilterGroup = -1;
    groundBody.collisionFilterMask = -1;
    world.addBody(groundBody);
    width = 400;
    height = 400;
    world.scene = scene = new seen.Scene({
      model: seen.Models["default"](),
      viewport: seen.Viewports.center(width, height)
    });
    avatar = world.scene.model;
    balls = [];
    allBall = function(r) {
      var b, j, len, results;
      results = [];
      for (j = 0, len = balls.length; j < len; j++) {
        b = balls[j];
        results.push(r(b));
      }
      return results;
    };
    balls.push(new RollerBall("Biggie", world, 100, 0.50, {
      position: new CANNON.Vec3(1, 1, 0.75)
    }));
    xform = seen.M().rotx(.3).scale(3);
    scene.camera.transform(xform).bake();
    floor = seen.Shapes.patch(50, 50);
    floor.translate(-25, -25, 0);
    floor.roty(Math.PI);
    floor.fill(new seen.Material(seen.C(100, 100, 100, 100)));
    floor.eachSurface(function(s) {
      return s.cullBackfaces = false;
    });
    avatar.add(floor.scale(-50));
    for (x = j = -5; j <= 5; x = ++j) {
      for (y = n = -5; n <= 5; y = ++n) {
        avatar.add(seen.Shapes.pipe(seen.P(x * 10, y * 10, 1), seen.P(x * 10, y * 10, 0), 0.5));
      }
    }
    context = seen.Context('seen-canvas', scene).render();
    FLIPXZ = new seen.Matrix([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1]);
    FLIPYZ = new seen.Matrix([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
    scene.model.transform(FLIPYZ);
    scene.model.rotx(Math.PI * 20 / 360);
    scene.model.bake();
    timeStamp = 0;
    startStop = false;
    onceStop = false;
    dropTime = 10000;
    simulateThem = function(t, dt) {
      var fixedTimeStep, lastTime, maxSubSteps;
      fixedTimeStep = 1.0 / 60.0;
      maxSubSteps = 3;
      lastTime = void 0;
      if (t > dropTime & balls.length < 14) {
        dropTime = t + fixedTimeStep * 100000;
        balls.push(new RollerBall("jack_" + dropTime, world, 10, 0.30, {
          position: new CANNON.Vec3(4, 4, 6)
        }));
      }
      if (startStop) {
        if (onceStop) {
          startStop = false;
          onceStop = false;
          allBall(function(b) {
            return console.log(b.A, b.outerSphere.position, b.innerSphere.position);
          });
        }
        world.step(fixedTimeStep, dt, maxSubSteps);
      }
      timeStamp += dt * 1e-2;
      allBall(function(b) {
        return b.update();
      });
    };
    m = Pylon.Mithril;
    seenModel = scene.model.append();
    dragger = new seen.Drag('seen-canvas', {
      inertia: true
    });
    dragger.on('drag.rotate', function(e) {
      var ref;
      xform = (ref = seen.Quaternion).xyToTransform.apply(ref, e.offsetRelative);
      return scene.camera.transform(xform);
    });
    zoomer = new seen.Zoom('seen-canvas', {
      smooth: false
    });
    zoomer.on('zoom.scale', function(e) {
      xform = seen.M().scale(e.zoom);
      return scene.camera.transform(xform);
    });
    context.animate().onBefore(simulateThem).start();
    return window.onkeypress = function(event) {
      switch (event.key) {
        case ".":
          onceStop = true;
          startStop = true;
          break;
        case ' ':
          startStop = !startStop;
          break;
        case 'h':
          allBall(function(b) {
            return b.setPursuit(-5, 0);
          });
          break;
        case 'j':
          allBall(function(b) {
            return b.setPursuit(4, 4);
          });
          break;
        case 'k':
          allBall(function(b) {
            return b.setPursuit(-3, -3);
          });
          break;
        case 'l':
          allBall(function(b) {
            return b.setPursuit(0, 0);
          });
          break;
        case 'c':
          allBall(function(b) {
            return b.clear();
          });
      }
    };
  })();
})();</script><div id="cover" style="background-image:url(/assets/images/hooray-fade2.jpg);-moz-transform:scaleX(-1);-o-transform:scaleX(-1);-webkit-transform:scaleX(-1);transform:scaleX(-1);filter:FlipH;ms-filter:FlipH"></div></div></body></html>